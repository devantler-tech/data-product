using System;
using System.Linq;
using System.Text;
using Devantler.DataMesh.DataProduct.Configuration;
using Devantler.SourceGenerator.Core;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.Extensions.Configuration;

namespace Devantler.DataMesh.DataProduct.Core.SourceGenerator;

[Generator]
public class ModelsGenerator : GeneratorBase
{
    public override void Generate(SourceProductionContext context, Compilation compilation, IConfiguration configuration)
    {
        var schemas = configuration.GetSection("Schemas").Get<Schema[]>();
        var @namespace = compilation.AssemblyName + ".Models";

        foreach (var schema in schemas)
        {
            string source = GenerateModel(@namespace, schema);
            context.AddSource($"{schema.Name}.cs", SourceText.From(source, Encoding.UTF8));
        }

        static string GenerateModel(string @namespace, Schema schema)
        {
            return string.Join(Environment.NewLine,
                "// <auto-generated />",
                $"namespace {@namespace};",
                $"public class {schema.Name}",
                "{",
                GenerateProperties(schema).IndentBy(4),
                "}"
            );
            static string GenerateProperties(Schema schema)
            {
                return string.Join(
                    Environment.NewLine,
                    schema.Properties.Select(
                        property => GenerateProperty(property)
                    )
                );

                static string GenerateProperty(Schema.Property x)
                {
                    return $"public {ParseType(x.Type)} {x.Name} {{ get; set; }}";

                    static string ParseType(string type)
                    {
                        var actualType = type.EndsWith("[]") ? type[..^2] : type;
                        var parsedType = actualType switch
                        {
                            "number" => "int",
                            "boolean" => "bool",
                            _ => $"{actualType}"
                        };
                        return type.EndsWith("[]") ? $"IEnumerable<{parsedType}>" : parsedType;
                    }
                }
            }
        }

    }
}
