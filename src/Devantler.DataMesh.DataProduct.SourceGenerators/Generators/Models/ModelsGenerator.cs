using System;
using System.Linq;
using System.Text;
using Devantler.DataMesh.DataProduct.SourceGenerators.Base;
using Devantler.DataMesh.DataProduct.SourceGenerators.Extensions;
using Devantler.DataMesh.DataProduct.SourceGenerators.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Devantler.DataMesh.DataProduct.SourceGenerators.Generators.Models;

[Generator]
public class ModelsGenerator : GeneratorBase, IIncrementalGenerator
{
    public override void Generate(SourceProductionContext context, Compilation compilation, Configuration configuration)
    {
        var @namespace = compilation.AssemblyName + ".Models";

        foreach (var schema in configuration.Schemas)
        {
            string source = GenerateModel(@namespace, schema);
            context.AddSource($"{schema.Name}.cs", SourceText.From(source, Encoding.UTF8));
        }

        static string GenerateModel(string? @namespace, Schema schema)
        {
            return string.Join(Environment.NewLine,
                "// <auto-generated />",
                $"namespace {@namespace};",
                $"public class {schema.Name}",
                "{",
                GenerateProperties(schema),
                "}"
            );
            static string GenerateProperties(Schema model)
            {
                return string.Join(
                    Environment.NewLine,
                    model.Properties.Select(
                        property => GenerateProperty(property)
                    )
                );

                static string GenerateProperty(Property x)
                {
                    return $"public {ParseType(x.Type)} {x.Name} {{ get; set; }}".IndentBy(4);

                    static string ParseType(string type)
                    {
                        var actualType = type.EndsWith("[]") ? type[0..^2] : type;
                        var parsedType = actualType switch
                        {
                            "number" => "int",
                            "boolean" => "bool",
                            _ => $"{actualType}"
                        };
                        return type.EndsWith("[]") ? $"IEnumerable<{parsedType}>" : parsedType;
                    }
                }
            }
        }
    }
}
